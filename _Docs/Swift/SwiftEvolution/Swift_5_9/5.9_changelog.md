## Swift 5.9

### 2023-09-18 (Xcode 15.0)

* [SE-0382][], [SE-0389][], [SE-0394][], [SE-0397][]:

  Swift 5.9 includes a new macro system that can be used to eliminate boilerplate and provide new forms of expressive APIs. Macros are declared with the new `macro` introducer:

  ```swift
  @freestanding(expression)
  macro assert(_ condition: Bool) = #externalMacro(module: "PowerAssertMacros", type: "AssertMacro")
  ```

  Macros have parameter and result types, like functions, but are defined as separate programs that operate on syntax trees (using [swift-syntax][]) and produce new syntax trees that are incorporated into the program. Freestanding macros, indicated with the `@freestanding` attribute, are expanded in source code with a leading `#`:

  ```swift
  #assert(x + y == z) // expands to check the result of x + y == z and report failure if it's false
  ```

  Macros can also be marked as `@attached`, in which case they will be meaning that they will be expanded using custom attribute syntax. For example:

  ```swift
  @attached(peer, names: overloaded)
  macro AddCompletionHandler() = #externalMacro(
    module: "ConcurrencyHelperMacros",
    type: "AddCompletionHandlerMacro"
  )
  
  @AddCompletionHandler
  func fetchAvatar(from url: URL) throws -> Image { ... }
  
  // expands to...
  func fetchAvatar(from url: URL, completionHandler: @escaping (Result<Image, Error>) -> Void) {
    Task.detached {
      do {
        let result = try await fetchAvatar(from: url)
        completionHandler(.success(result))
      } catch {
        completionHandler(.failure(error))
      }
    }
  }
  ```

  Macros are implemented in separate programs, which are executed by the Swift compiler. The Swift Package Manager's manifest provides a new `macro` target type to describe macros:

  ```swift
  import PackageDescription
  import CompilerPluginSupport
  
  let package = Package(
      name: "ConcurrencyHelpers",
      dependencies: [
          .package(url: "https://github.com/apple/swift-syntax", from: "509.0.0"),
      ],
      targets: [
          .macro(name: "ConcurrencyHelperMacros",
                 dependencies: [
                     .product(name: "SwiftSyntaxMacros", package: "swift-syntax"),
                     .product(name: "SwiftCompilerPlugin", package: "swift-syntax")
                 ]),
          .target(name: "ConcurrencyHelpers", dependencies: ["ConcurrencyHelperMacros"]),
          .testTarget(name: "ConcurrencyHelperMacroTests", dependencies: ["ConcurrencyHelperMacros"]),
      ]
  )
  ```

* [SE-0380][]:

  `if` and `switch` statements may now be used as expressions to:

  * Return values from functions, properties, and closures (either with
    implicit or explicit `return`)
  * Throw errors using `throw`
  * Assign values to variables
  * Declare variables

  Each branch of the `if` or `switch` must be a single expression, the value
  of which becomes the value of the overall expression when that branch is
  chosen.

  ```swift
  let bullet =
    if isRoot && (count == 0 || !willExpand) { "" }
    else if count == 0 { "- " }
    else if maxDepth <= 0 { "▹ " }
    else { "▿ " }
  ```

  ```swift
  public static func width(_ x: Unicode.Scalar) -> Int {
    switch x.value {
      case 0..<0x80: 1
      case 0x80..<0x0800: 2
      case 0x0800..<0x1_0000: 3
      default: 4
    }
  }
  ```

* [#64927][]:

  Swift 5.9 introduces warnings that catch conversions from an inout
  argument in the caller to an `UnsafeRawPointer` in the callee
  whenever the original type contains an object reference.

  ```swift
  func inspectString(string: inout String) {
    readBytes(&string)
    // warning: forming an 'UnsafeRawPointer' to an inout variable of type String
    // exposes the internal representation rather than the string contents.
  }
  ```

  ```swift
  func inspectData(data: inout Data) {
    readBytes(&data)
    // warning: forming an 'UnsafeRawPointer' to a variable of type 'T';
    // this is likely incorrect because 'T' may contain an object reference.
  }
  ```

  Please see the "Workarounds for common cases" section link in github
  issue #64927.

* Marking stored properties as unavailable with `@available` has been banned,
  closing an unintentional soundness hole that had allowed arbitrary
  unavailable code to run and unavailable type metadata to be used at runtime:
  
  ```swift
  @available(*, unavailable)
  struct Unavailable {
    init() {
      print("Unavailable.init()")
    }
  }

  struct S {
    @available(*, unavailable)
    var x = Unavailable()
  }

  _ = S() // prints "Unavailable.init()"
  ```
  
  Marking `deinit` as unavailable has also been banned for similar reasons.

* [SE-0366][]:

  The lifetime of a local variable value can be explicitly ended using the
  `consume` operator, forwarding ownership to the surrounding call, assignment,
  or initialization without copying:

  ```swift
  var x: [String] = []
  x.append("apples")
  x.append("bananas")
  x.append("oranges")

  process(consume x) // forward the current value, without copying

  x = [] // start building a new value
  x.append("broccoli")
  x.append("cauliflower")
  x.append("asparagus")
  ...
  ```

* [SE-0377][]:

  Functions can now declare whether they take value parameters by `borrowing`
  access to a value provided by the caller, or by `consuming` a value that the
  callee is allowed to take ownership of:

  ```swift
  struct HealthyFoods {
    var values: [String] = []

    // Ask to `consume` the parameter, since we want to use it
    // to incorporate into our own `values` array
    mutating func add(_ value: consuming String) {
        values.append(value)
    }
  }
  ```

